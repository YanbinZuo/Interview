### 1. 作用域：       
       C++中作用域以花括号分隔，作用域中声明的名字(变量，常量，类型，函数)，它所嵌套的作用域也能访问

### 2. 原码，反码，补码：
        * 将带符号位的机器数对应的真正数值称为机器数的真值。例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1
        * 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制: [+1]原 = 0000 0001， [-1]原 = 1000 0001
        * 反码的表示方法是: 正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。[+1] = [00000001]原 = [00000001]反， [-1] = [10000001]原 = [11111110]反
        * 补码的表示方法是: 正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) 
        [+1] = [00000001]原 = [00000001]反 = [00000001]补，  [-1] = [10000001]原 = [11111110]反 = [11111111]补    
        * 使用原码，反码和补码的原因：首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 
        加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法.     
        我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.于是人们开始探索 将符号位参与运算,     
        并且只保留加法的方法. 首先来看原码:    1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2。   
        如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.   
        为了解决原码做减法的问题, 出现了反码:   1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0    
        发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上。于是补码的出现, 解决了0的符号以及两个编码的问题:    
        1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原
        这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:   
        (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补     
        -1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.    
        使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].



### 3. 泛型：   
       * 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？答案是可以使用 Java 泛型。   

       public class GenericMethodTest
       {
              // 泛型方法 printArray                         
              public static < E > void printArray( E[] inputArray )
              {
              // 输出数组元素            
                     for ( E element : inputArray ){        
                            System.out.printf( "%s ", element );
                     }
                     System.out.println();
              }
 
    public static void main( String args[] )
    {
        // 创建不同类型数组： Integer, Double 和 Character
        Integer[] intArray = { 1, 2, 3, 4, 5 };
        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };
 
        System.out.println( "整型数组元素为:" );
        printArray( intArray  ); // 传递一个整型数组
 
        System.out.println( "\n双精度型数组元素为:" );
        printArray( doubleArray ); // 传递一个双精度型数组
 
        System.out.println( "\n字符型数组元素为:" );
        printArray( charArray ); // 传递一个字符型数组
    } 
} 

       下面的例子演示了"extends"如何使用在一般意义上的意思"extends"（类）或者"implements"（接口）。该例子中的泛型方法返回三个可比较对象的最大值。    
        public class MaximumTest
       {
       // 比较三个值并返回最大值
              public static <T extends Comparable<T>> T maximum(T x, T y, T z)
              {                     
                     T max = x; // 假设x是初始最大值
                     if ( y.compareTo( max ) > 0 ){
                            max = y; //y 更大
                     }
                     if ( z.compareTo( max ) > 0 ){
                            max = z; // 现在 z 更大           
                     }
                     return max; // 返回最大对象
              }
              public static void main( String args[] )
              {
                     System.out.printf( "%d, %d 和 %d 中最大的数为 %d\n\n",
                     3, 4, 5, maximum( 3, 4, 5 ) );
 
                     System.out.printf( "%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n",
                   6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) );
 
                     System.out.printf( "%s, %s 和 %s 中最大的数为 %s\n","pear",
                     "apple", "orange", maximum( "pear", "apple", "orange" ) );
              }

