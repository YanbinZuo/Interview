### 1.The difference between HashMap and HashSet:
                                              1. 实现的接口不同，hashmap实现的是map接口，hashset实现的是set接口。
                                              2. 存储的数据不同，hashmap存储键值对，hashset存储对象。
                                              3. 添加元素的方法不同，hashmap使用put()方法，hashset使用add()方法。
                                              4. Hashcode计算方式不同，Hashmap使用key计算hashcode，hashset使用对象计算hashcode。
HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码⾮常⾮常少，因为除了 clone() 、 writeObject() 、 readObject() 是 HashSet ⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。
https://www.yuque.com/gaohanghang/sgrbwh/kyb5zl

### 2. The difference between Bubble Sort, Selection Sort, and Insertion Sort:
- [ ] a. Bubble Sort     //(从小到大)两个两个进行比较往右移，第一回合把最大的移到最右面，以此类推
  对于一个数比较与之相邻的数字，例如要把一个数列按从小到大的顺序排列，就拿左边第一个数，和第二的比，若小于第二个数两个交换，否则不换，再比较第二个和第三个，按照同样的规则，继续第三第四…直到最     后。这样就算一次冒泡，每次冒泡都会有一个数被放到了最终的位置。
- [ ] b. Selection Sort  //(从小到大)把数组分为已排序区和未排序区，它每次找到未排序区的最小值，与未排序区的首个元素交换，这样就变成了已排序区的末尾元素了。
- [ ] c. Insertion Sort  //(从小到大)插入排序把数组分为已排序区和未排序区。取未排序区的元素，在已排序区上找到一个正确的位置插上去。还是希望对一个数据进行从小到大的排序。
- [ ] d. Heap Sort
- [ ] e. Quick Sort      // divide and conquer
- [ ] f. Quick Select    //和quick sort很像 都需要partition step。 不同的是recursion部分
a,b,c 对比 https://blog.csdn.net/weixin_39679367/article/details/83188391

### 3. OS:
  **程序：** 硬盘上的一个 .exe文件。每当点击一个程序时，os会启动一个相对应的进程，再次双击会出现又一个进程。一个程序会有好多个进程，进程是一个程序跑起来了，放到内存里开始执行了，CPU开始执行它的指令   了。在一个进程里有好多的工作是并行进行的比如刷新页面，接收网络的传输，存盘。这些东西是并行进行通过线程的。在一个新成立可以做并行任务，一个线程里不同的执行路径叫做纤程（协程，JAVA： fiber）。    
  **进程：** 分配资源的单位。启动一个进程的时候，会分配内存空间，这是虚拟内存，但最后也会映射到物理内存上。    
  **线程：** 执行单位。起线程的时候不会分配内存空间，这些线程共享这个内存空间。所以，分配资源按照进程，执行资源按照线程。    
  **程序的本质：**（一堆的指令+一堆的数据）读取指令与数据-计算-写回    
  
  高级语言 -> 汇编语言 -> 机器语言    （MOVE    100101001）
  编译就是把高级语言翻译成机器语言的一个过程。
  https://www.bilibili.com/video/BV1g54y1s79n?p=12&spm_id_from=pageDriver （P11）
  
  * CPU通过总线读取内存中的数据。内存中执行不同的程序，程序可以理解为一条一条的指令。PC（指令寄存器）存着下一条指令的地址，指令里有很多的数据，CPU需要把数据从内存里拿进来，存起来，存在寄存器（register）里面。寄存器的数量非常多，有好几十个，每个都有不同的作用，ALU进行一系列具体的计算，计算之后写回到内存里。
  * CPU从内存里读取速度很慢，所以需要缓存器(Cache)里面包括L1, L2, L3,经常使用的数据可以放到L1里面，L1读取速度非常快，可以缩短读取时间。L1找不到去L2里找，L2找不到去L3里找，L3也找不到就再去内存里读取。多核CPU，每一个核都有自己的L1,L2缓存，但是所有的核共享L3缓存，多块CPU共享内存。
  * 线程是CPU执行的最基本的单位，执行每一个程序的时候执行的是线程。 恢复线程：（切换线程）运行一个线程到一半后如果运行另一个线程，需要把PC里面的指令，Register里面的数据放回到内存或者缓存里。再次调用的时候选哟放到PC和Register里面原来的位置。所以叫恢复线程。ALU是运算非常快的运算单元，超线程：恢复线程会很慢，但是如果是两组register and PC, ALU在每一组中进行运算，最后总时间比恢复线程要快得多，所以叫超线程。正式概念,超线程：一个ALU对应多个PC和register。所谓的四核八线程就是一个CPU里有四个ALU，每一个ALU对应着两组寄存器和PC。
  * CPU乱序执行：CPU读取指令的同时可以同时执行不影响的其他指令而写的同时可以合并写，这样效率更高。
  * Cache里的数值和内存里的不一样，dirty变为1。
  
  class T{                                                    汇编码：  new #2 <T>
    int m = 8;                                                         dup
  }                                                                    invokespecial #3 <T.<int>>
  T t = new T();                                                       astore_1
                                                                       return
  对象的创建过程：（new #2 <T>）new一个对象的时候会在堆内存里分配一块内存，如果有成员变量m，当刚new完这个对象的时候，这个m是默认值为0，当<T.<int>>这个构造方法(initialize)运行完之后才会给m初始值8. 最后的astoer-1是把这个对象(new T())赋值给t.所以本质上是三步，分配内存，初始化，建立关联。    
  volatile 的主要作用有两点： - 保证变量的内存可见性 - 禁止指令重排序。DLC要加volatile


### 4. 单例模式：
  **意图：** 保证一个类只有一个实例，并提供一个访问它的全局访问点。设备管理器为单例模式。Windows是多进程多线程的，不可避免同时操作一个文件，所以多有文件必须通过唯一实例来进行。      
  **有点：** 在内存里只有一个实例，减少了内存开销；避免对资源的多重占用。    
  **缺点：** 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。


### 5. TCP/IP    https://www.bilibili.com/video/BV1Vy4y177YB?p=2     
  **a** OSI7层参考模型：应用层，表示层，会话层，传输控制层，网络层，链路层，物理层   
      TCP/IP: (客户端)
        程序  应用层
        内    传输控制层
        核    网络层
        公    链路层
        共    物理层




### 6. Git/SVN   
    SVN: SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做的东西推到中央服务器。
    集中版本控制系统是需要联网的，对网络宽带要求比较高。   
    Git：Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己的电脑上。协同的方法就是这样的：比如说自己在电脑上改了文件A，其他人
    在电脑上也改了文件A，这时你们俩之间只需要把各自的修改推给对方，就可以互相看到对方的修改了。Git是目前世界上最先进的版本控制系统。
