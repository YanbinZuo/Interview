### 1.The difference between HashMap and HashSet:
                                              1. 实现的接口不同，hashmap实现的是map接口，hashset实现的是set接口。
                                              2. 存储的数据不同，hashmap存储键值对，hashset存储对象。
                                              3. 添加元素的方法不同，hashmap使用put()方法，hashset使用add()方法。
                                              4. Hashcode计算方式不同，Hashmap使用key计算hashcode，hashset使用对象计算hashcode。
HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码⾮常⾮常少，因为除了 clone() 、 writeObject() 、 readObject() 是 HashSet ⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。
https://www.yuque.com/gaohanghang/sgrbwh/kyb5zl

### 2. The difference between Bubble Sort, Selection Sort, and Insertion Sort:
- [ ] a. Bubble Sort     //(从小到大)两个两个进行比较往右移，第一回合把最大的移到最右面，以此类推
  对于一个数比较与之相邻的数字，例如要把一个数列按从小到大的顺序排列，就拿左边第一个数，和第二的比，若小于第二个数两个交换，否则不换，再比较第二个和第三个，按照同样的规则，继续第三第四…直到最     后。这样就算一次冒泡，每次冒泡都会有一个数被放到了最终的位置。
- [ ] b. Selection Sort  //(从小到大)把数组分为已排序区和未排序区，它每次找到未排序区的最小值，与未排序区的首个元素交换，这样就变成了已排序区的末尾元素了。
- [ ] c. Insertion Sort  //(从小到大)插入排序把数组分为已排序区和未排序区。取未排序区的元素，在已排序区上找到一个正确的位置插上去。还是希望对一个数据进行从小到大的排序。
- [ ] d. Heap Sort
- [ ] e. Quick Sort      // divide and conquer
- [ ] f. Quick Select    //和quick sort很像 都需要partition step。 不同的是recursion部分
a,b,c 对比 https://blog.csdn.net/weixin_39679367/article/details/83188391

### 3. OS:
  **程序：** 硬盘上的一个 .exe文件。每当点击一个程序时，os会启动一个相对应的进程，再次双击会出现又一个进程。一个程序会有好多个进程，进程是一个程序跑起来了，放到内存里开始执行了，CPU开始执行它的指令   了。在一个进程里有好多的工作是并行进行的比如刷新页面，接收网络的传输，存盘。这些东西是并行进行通过线程的。在一个新成立可以做并行任务，一个线程里不同的执行路径叫做纤程（协程，JAVA： fiber）。    
  **进程：** 分配资源的单位。启动一个进程的时候，会分配内存空间，这是虚拟内存，但最后也会映射到物理内存上。    
  **线程：** 执行单位。起线程的时候不会分配内存空间，这些线程共享这个内存空间。所以，分配资源按照进程，执行资源按照线程。线程共享堆(对象实例)，方法区（静态常量，全局变量），（字符串常量池）
  线程私有:program counter，虚拟机栈，本地方法栈
  **程序的本质：**（一堆的指令+一堆的数据）读取指令与数据-计算-写回    
  
  高级语言 -> 汇编语言 -> 机器语言    （MOVE    100101001）
  编译就是把高级语言翻译成机器语言的一个过程。
  https://www.bilibili.com/video/BV1g54y1s79n?p=12&spm_id_from=pageDriver （P11）
  
  * CPU通过总线读取内存中的数据。内存中执行不同的程序，程序可以理解为一条一条的指令。PC（指令寄存器）存着下一条指令的地址，指令里有很多的数据，CPU需要把数据从内存里拿进来，存起来，存在寄存器（register）里面。寄存器的数量非常多，有好几十个，每个都有不同的作用，ALU进行一系列具体的计算，计算之后写回到内存里。
  * CPU从内存里读取速度很慢，所以需要缓存器(Cache)里面包括L1, L2, L3,经常使用的数据可以放到L1里面，L1读取速度非常快，可以缩短读取时间。L1找不到去L2里找，L2找不到去L3里找，L3也找不到就再去内存里读取。多核CPU，每一个核都有自己的L1,L2缓存，但是所有的核共享L3缓存，多块CPU共享内存。
  * 线程是CPU执行的最基本的单位，执行每一个程序的时候执行的是线程。 恢复线程：（切换线程）运行一个线程到一半后如果运行另一个线程，需要把PC里面的指令，Register里面的数据放回到内存或者缓存里。再次调用的时候选哟放到PC和Register里面原来的位置。所以叫恢复线程。ALU是运算非常快的运算单元，超线程：恢复线程会很慢，但是如果是两组register and PC, ALU在每一组中进行运算，最后总时间比恢复线程要快得多，所以叫超线程。正式概念,超线程：一个ALU对应多个PC和register。所谓的四核八线程就是一个CPU里有四个ALU，每一个ALU对应着两组寄存器和PC。
  * CPU乱序执行：CPU读取指令的同时可以同时执行不影响的其他指令而写的同时可以合并写，这样效率更高。
  * Cache里的数值和内存里的不一样，dirty变为1。
  
  class T{                                                    汇编码：  new #2 <T>
    int m = 8;                                                         dup
  }                                                                    invokespecial #3 <T.<int>>
  T t = new T();                                                       astore_1
                                                                       return
  对象的创建过程：（new #2 <T>）new一个对象的时候会在堆内存里分配一块内存，如果有成员变量m，当刚new完这个对象的时候，这个m是默认值为0，当<T.<int>>这个构造方法(initialize)运行完之后才会给m初始值8. 最后的astoer-1是把这个对象(new T())赋值给t.所以本质上是三步，分配内存，初始化，建立关联。    
  volatile 的主要作用有两点： - 保证变量的内存可见性 - 禁止指令重排序。DLC要加volatile

  
  虚拟内存： 一个进程存储一个内存，刚开始的时候没必要把所有东西放到内存，有用的东西放到内存，没用的东西可以放到硬盘里面去，这样来节省内存空间。只把用到的数据放到物理内存上，剩下的放到虚拟内存上。
  怎么把物理内存映射到虚拟内存上：需要做一个映射表，这个映射表就是把物理内存上的页映射到虚拟内存上，这一个表称作为页表 包括页框和偏移量。
  虚拟内存就是进一步扩大内存的地址空间，把进程的一部分转换到电脑磁盘上，
  把内存地址的转换（虚拟内存到物理内存上）需要三个步骤：1. 把虚拟内存的地址切成页号和偏移量的组合  2. 从页表里面查询出虚拟页号和对应的物理页号   3. 直接拿到物理页号然后加上偏移量 这样的到物理地址

### 4. 单例模式：
  **意图：** 保证一个类只有一个实例，并提供一个访问它的全局访问点。设备管理器为单例模式。Windows是多进程多线程的，不可避免同时操作一个文件，所以多有文件必须通过唯一实例来进行。      
  **有点：** 在内存里只有一个实例，减少了内存开销；避免对资源的多重占用。    
  **缺点：** 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。


### 5. TCP/IP    https://www.bilibili.com/video/BV1Vy4y177YB?p=2     
      TCP/IP: (客户端)      
        程序  应用层    
        内    传输层   
        核    网络层   
        公    链路层   
  
     osi model：
              物理层： 将数据转换为可通过物理介质传送的电子信号 相当于邮局中的搬运工人。     
              数据链路层： 提供介质访问，链路管理等 决定访问网络介质的方式。  
              网络层：寻址和路由的选择，相当于邮局中的排序工人。     
              传输层：提供终端到终端的可靠连接 相当于公司中跑邮局的送信职员。   
              会话层：建立维护和管理会话，允许用户使用简单易记的名称建立连接 相当于公司中收寄信、写信封与拆信封的秘书。   
              表示层：处理数据交换格式，数据和加密等。 相当公司中简报老板、替老板写信的助理。    
              应用层：用户的应用程序和网络之间的接口。     

### TCP和UDP的区别：
  TCP是面向连接的协议，UDP是面向无连接协议。     
  UDP继承了一个IP包的特性   
  TCP是面向字节流的协议 有状态服务    
  UDP是面向包的协议，基于数据包来的 无状态服务 
  TCP: Transmission control protocol   
  TCP保证所有数据不丢失，是有序的。比如浏览网页的时候如果没有TCP的话整个网页就是一种无序的状态，并且可能丢失一些数据 （下载东西也一样）   
#### 三次握手
  三次我是保证TCP协议的安全传输  
  TCP是面向连接的协议(connection oriented protocol)，两台计算机再进行任何通信之前都要首先建立TCP逻辑连接，这时就是使用了三次握手：首先是发送方向计算机发送一个SYN信息给接收方，然后接收方计算机发回一个确认信息(SYN ACK) 告诉发送方自己已经接收到SYN信息, 最后发送方计算机发送另一个确认消息给接收方(ACK RECEIVED).   
#### 四次挥手
  四次挥手是发送方想要断开连接的时候，第一次发送方发送FIN给接收方表明我要断开连接，第二次是接收方发送ACK给发送方表明我收到你断开连接的请求了但是我还没有准备好断开， 第三次是接收方然后发送回FIN给发送方表明可以断开连接，最后第四次发送方发送确认消息给接收方(ACK)表明收到信息。   
  1. 通过这三次握手之后TCP双方就可以收发数据了。 一个重点是TCP保证了数据的传送到达  
  2. 如果数据包误码或丢失，TCP会对其进行重新传输
  UDP：Usser Datagram protocol
  UDP也用于发送和接收数据，但是UDP是无连接的(connectionless oriented protocol) 也就是说通信之前无需建立逻辑连接，不保证数据传输的可靠性。   
  所以当计算机使用UDP的时候，发送方并不关心数据是否被另一端收到，因此，UDP的传输速度会比TCP更快
  
  
  UDP的三大特点：
  1. 简单，无需握手
  2. 他不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。
  3. 他不会根据网络的情况发包的拥塞控制，无论网络丢包丢成啥样了，他该怎么发还怎么发。
  UDP的使用场景：
  1. 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用
  2、 不需要一对一沟通，建立连接，而是可以广播的用用，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据
  3. 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也不能减慢发送速度  （实时性）
  http3.0及以后的采用的时UDP协议，3.0之前的时TCP协议


### 6. Git/SVN   
    SVN: SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做的东西推到中央服务器。
    集中版本控制系统是需要联网的，对网络宽带要求比较高。   
    Git：Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网，因为版本都在自己的电脑上。协同的方法就是这样的：比如说自己在电脑上改了文件A，其他人
    在电脑上也改了文件A，这时你们俩之间只需要把各自的修改推给对方，就可以互相看到对方的修改了。Git是目前世界上最先进的版本控制系统。
  
  
### Hashmap
  HashMap由数组，链表和红黑树组成。Hashmap数组部分成为哈希桶，当链表长度大于等于8时，链表数据会以红黑树的形式进行储存，当长度降低到6时，转成链表。 链表时间复杂度O(n), 红黑树的时间复杂度O(logn)  
  每个node节点存储着用来定位数据索引位置的hash值, key, value以及指向链表下一个节点的noade<k, v> next节点组成。 node是hashmap的内部类，实现了map.entry接口，本质是一个键值。  
  hashmap首先调用hashcode()方法，获取key的hashcode的值然后对其进行高位运算
