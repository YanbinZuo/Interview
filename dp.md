# 动态规划

例题：在一个长方形格格里，robot从左上角走到右下角  
1. 什么是动态规划：三种情况：

    a. 计数

    		- 有多少种方式走到右下角

       - 有多少种方法选出k个数使得和是sum

    b. 求最大最小值

    	- 从左上角走到右下角路径的最大数字和  
    	- 最长上升子序列长度

    c. 求存在性 

    	- 取石子游戏，先手是否必赢 
    	- 能不能选出k个数使得和是sum   



 *Lintcode 669: Coin Change*
 你有三枚硬币，分别面值为2元，5元和7元，每种硬币都有足够多，买一本书需要27元，如何用最少的硬币组合正好付清，不需要对方找钱。

​    思想一：尽量用大的硬币 7+7+7+2+2+2=27 共六枚硬币

​	正确答案：7+5+5+5+5 = 27 共五枚硬币  

2. 动态规划组成部分一：确定状态   
   * 状态在动态规划中的作用属于定海神针    

   * 简单地说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么  

      * 类似于解数学题中，X, Y, Z代表什么      

   * 确定状态需要两个意识：    

      - 最后一步

         - 子问题     
    - [x] 最后一步：
           
               - 虽然我们不知道最优策略是什么，但是最优策略肯定是k枚硬币，a1, a2, a3, ..... ak面值加起来是27
                
           -  所以一定有最后一枚硬币：ak
           
           -  除掉这枚硬币，前面的硬币总面值加起来是27-ak
           
    - [ ] 子问题：

         - 所以我们就要求：最少可以用多少枚硬币可以拼出27-ak
- 原问题是最少用多少枚硬币拼出27
         - 我们将原问题转化成了一个子问题，而且规模更小：27-ak
- 为了简化定义，我们设状态f(x) = 最少用多少枚硬币可以拼出x
         

如果ak是2, f(27)应该是f(27-2) + 1（加上最后这一枚硬币2）
         
         如果ak是5, f(27)应该是f(27-5) + 1（加上最后这一枚硬币5）
         
         如果ak是7, f(27)应该是f(27-7) + 1（加上最后这一枚硬币7）
         
         需要求最少的硬币数，所以：f(27) = min{f(27-2)+1, f(27-5)+1, f(27-7)+1}



​			  递归解法： 

​					int f(int x){

​						if(x == 0)return 0;

​						int res = MAX_VALUE;

​						if(x >= 2) res = Math.min(f(x-2)+1 res);

​						if(x >= 5) res = Math.min(f(x-5)+1, res);

​						if(x >= 7) res = Math.min(f(x-7)+1, res);

​					}

​			递归解法的问题：                               f(27)

​								f(25)                                  f(22)                                      f(20)

​				f(23)    f(20)    f(18)             f(20)    f(17)    f(15)                f(18)    f(15)    f(13)

​			可以看到f(20)多次用到，不仅仅用到的f(20)， 包含他底下的所有的数值。

​			做了很多重复计算，效率低下

​			而对于动态规划：东塔规划是将计算结果保存下来，并改变计算顺序

 2. 动态规划组成部分二：转移方程

    设状态f[x]=最少用多少枚硬币拼出x

    对于任意x, f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}   

	3. 动态规划组成部分三：初始条件和边界情况

    f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}   

    两个问题：x-2, x-5 或者x-7小于0怎么办？什么时候停下来？

    如果不能拼出y, 就定义f[y]=正无穷

    ​	例如f[-1] = f[-2] = .... = 正无穷

    所以f[1]=min{f[-1]+1, f[-4]+1, f[-6]+1} = 正无穷，表示拼不出来1

    初始条件：f[0] = 0. 初始条件就是用转移方程算不出来的，需要手动定义

	4. 动态规划组成部分四：计算顺序

    拼出x所需要的最少硬币数：f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}   

    初始条件：f[0] = 0

    然后计算f[1], f[2], ... , f[27]

    怎么区分从小到大还是从大到小：当我们计算到f[x]时， f[x-2], f[x-5], f[x-7]都已经得到结果了

    ​	这样就是从大到小，反之从小到大

    f[x] = 最少用多少枚硬币拼出x

    f[x] = ∞ 表示无法用硬币拼出x

    

    | ...  | f[-1] | f[0] | f[1] | f[2] | f[3] | f[4] | f[5] | f[6] | ...  | f[27] |
    | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- |
    | ∞    | ∞     | 0    | ∞    | 1    | ∞    | 2    | 1    | 3    | ...  | 5     |

    

    * 每一步尝试三种硬币，一共27步
    * 与递归算法相比，没有任何重复计算
    * 算法时间复杂度（即需要进行的步数）: 27 * 3
    * 递归的时间复杂度是指数级别， >> 27*3

	5. 小结

    * 求最值型动态规划
    * 动态规划组成部分：
      * 确定状态
        * 最后一步（最优策略中使用的最后一枚硬币ak）
        * 化成子问题（最少的硬币拼出更小的面值27-ak）
      * 转化方程
        * f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}  
      * 初始条件和边界情况
        * f[0] = 0， 如果不能拼出y, f[y] = 正无穷
      * 计算顺序
        * f[0], f[1], f[2], ...大部分从小到大
        * 使用条件是f[x-2], f[x-5], f[x-7]先于f[x]
    * 消除冗余，加速计算



code:

//A = {2, 5, 7}, M = 27

public int coinChange(int[] A, int M){

//如果用到0...n:数组范围开到[n+1]

//如果用到0...n-1:数组范围开到[n]

​	int[] f = new int[M+1];

​	int n = A.length; //number of kinds of coins

//initialization

​	f[0] = 0;

​	int i, j;

// f[1], f[2], ..., f[27]

​	for(i = 1; i <=M; i++){

​		f[i] = Integer.MAX_VALUE;

​		//last coin A[j]

​		// f[i] = min{f[i-A[0]]+1,..., f[i-A[n-1]]+1}

​		for(j = 0; j < n; j++){

​			if(i >= A[j] && f[i-A[j]] != Integer.MAX_VALUE){

​				f[i] = Math.min(f[i-A[j]] + 1, f[i])

​			}

​		}

​		if(f[M] == Integer.MAX_VALUE){

​			f[M] = -1;

​		}

​		return f[M];

​	}

}









## 问题二：

LintCode 114: Unique Paths

题意： 给定m行n列的网格，有一个机器人从左上角(0, 0)出发，每一步可以向下或者向右走一步

问：有多少种不同的方式走到右下角

|      | 0     | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | begin |      |      |      |      |      |      |      |
| 1    |       |      |      |      |      |      |      |      |
| 2    |       |      |      |      |      |      |      |      |
| 3    |       |      |      |      |      |      |      | end  |

### 动态规划组成部分一：确定状态

* 最后一步：无论机器人用何种方式走到右下角，总有最后挪动的一步：向右或者向下
* 右下角坐标设为(m-1, n-1)

### 子问题：

* 那么，如果机器人有x种方式从左上角走到(m-2, n-1), 有y种方式从左上角走到(m-1, n-2)，则机器人有x+y种方式走到(m-1, n-1)
  * 为什么是x+y呢？
  * 加法原理：从城市A走到城市B有2种方式，从城市B走到城市C有3种方式，从A到C共有2+3=5种方式
  * 加法原理使用条件：无重复，无遗漏
* 问题转化为，机器人从左上角走到(m-2, n-1)和(m-1, n-2)共有多少种方式？
* 原题要求有多少种方式从左上角走到(m-1, n-1)
* 子问题
* 问题：开几维数组呢？ 要求的量和状态量进行对照，有几个变量就开几维数组
* 这道题中有(m-1, n-1)m, n两个变量，所以二维数组
* 状态：设f[i] [j] 为机器人有多少种方式从左上角走到(i, j)

### 动态规划组成部分二：转移方程

* 对于任意一个格子(i, j), f[i] [j]  ''(机器人有多少种方式走到(i, j))  = f[i-1] [j] '(机器人有多少种方式走到(i-1, j))' + f[i] [j-1] '(机器人有多少种方式走到(i, j-1))'

### 动态规划组成部分三：初始条件和边界情况

* 初始条件：f[0] [0] = 1，因为机器人只有一种方式到左上角
* 边界情况：i = 0 or j = 0, 则前一步只能有一个方向过来

### 动态规划组成部分四：计算顺序

* f[0] [0] = 1
* 计算第0行: f[0] [0], f[0] [1], ..., f[0]  [n-1]
* 计算第1行: f[1] [0], f[1] [1], ..., f[1] [n-1]
* ...
* 计算第m-1行: f[m-1] [0], f[m-1] [1], ..., f[m-1] [n-1]
* 答案是f[m-1] [n-1]
* 时间复杂度（计算步数）：O（MN）， 空间复杂度（数组大小）： O（MN）

### 动态规划组成部分五：编程

public int uniquePaths(int m, int n){ // m and n are columns and rows

​	int[] [] f = new int[m] [n];

​	for(int i = 0; i < m; i++){// row: top to down

​		for(int j = 0; j < n; j++){// column: left to right

​			if(i == 0 || j == 0){

​				f[i] [j] = 1;

​			}else{

​				f[i] [j] = f[i-1] [j] + f[i] [j-1];

​			}

​		}

​		return f[m-1] [n-1]; // 为什么是m-1, n-1?因为题目说是mxn的表格，从0开始最后一行最后一列就是m-1, n-1.

​	}

}





LinCode 116 Jump Game （存在型动态规划）

* 有n块石头分别在x轴的0, 1, ..., n-1位置
* 一只青蛙在石头0, 想跳到石头n-1
* 如果青蛙在第i块石头上，它最多可以向右跳距离ai
* 问青蛙能否跳到石头n-1
* 例子：输入a=[2, 3, 1, 1, 4] 输出：True
* 例子：输入a=[3, 2, 1, 0, 4] 输出：False

### 动态规划组成部分一：确定状态

* 最后一步：如果青蛙能跳到最后一块石头n-1， 我们考虑它跳的最后一步
* 这一步是从石头i跳古来，i<n-1
* 这需要两个条件同时满足：
  * 青蛙可以跳到石头i
  * 最后一步不超过跳跃的最大距离：n-1-i<=ai
* 子问题：
  * 那么，我们需要知道青蛙能不能跳到石头i(i<n-1)
  * 而我们原来要求青蛙能不能跳到石头n-1
  * 状态：设f[j]表示青蛙能不能跳到石头j

### 动态规划组成部分二：转移方程

* 设f[j]表示青蛙能不能跳到石头j
  * f[j]（青蛙能不能跳到石头j） = OR0<=i<j（枚举上一个跳到的石头i） (f[i] （青蛙能不能跳到石头i） AND i + a[i] >= j（最后一步不超过ai）)

### 动态规划组成部分三：初始条件和边界情况

* 设f[j]表示青蛙能不能跳到石头j
* 初始条件：f[0] = True，因为青蛙一开始就在石头0

### 动态规划组成部分四：计算顺序

* 设f[j]表示青蛙能不能跳到石头j
* f[j]（青蛙能不能跳到石头j） = OR0<=i<j（枚举上一个跳到的石头i） (f[i] （青蛙能不能跳到石头i） AND i + a[i] >= j（最后一步不超过ai）)
* 初始化f[0] = True
* 计算f[1], f[2], ..., f[n-1]
* 答案是f[n-1]
* 时间复杂度：O(N^2), 空间复杂度（数组大小）：O(N)

public boolean canJump(int[] A){

​	int n = A.length;

​	boolean[] f  = new boolean[n];

​	f[0] = true;

​	for(int j = 1; j < n; j++){

​		for(int i = 0; i < j; i++){

​			if(f[i] && i + A[i] >= j){

​				f[j] = true;

​				break;

​			}

​		}

​		return f[n-1];

​	}

}