# 动态规划

例题：在一个长方形格格里，robot从左上角走到右下角  
1. 什么是动态规划：三种情况：

    a. 计数

    		- 有多少种方式走到右下角

       - 有多少种方法选出k个数使得和是sum

    b. 求最大最小值

    	- 从左上角走到右下角路径的最大数字和  
    	- 最长上升子序列长度

    c. 求存在性 

    	- 取石子游戏，先手是否必赢 
    	- 能不能选出k个数使得和是sum   



 *Lintcode 669: Coin Change*
 你有三枚硬币，分别面值为2元，5元和7元，每种硬币都有足够多，买一本书需要27元，如何用最少的硬币组合正好付清，不需要对方找钱。

​    思想一：尽量用大的硬币 7+7+7+2+2+2=27 共六枚硬币

​	正确答案：7+5+5+5+5 = 27 共五枚硬币  

2. 动态规划组成部分一：确定状态   
   * 状态在动态规划中的作用属于定海神针    

   * 简单地说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么  

      * 类似于解数学题中，X, Y, Z代表什么      

   * 确定状态需要两个意识：    

      - 最后一步

         - 子问题     
    - [x] 最后一步：
           
               - 虽然我们不知道最优策略是什么，但是最优策略肯定是k枚硬币，a1, a2, a3, ..... ak面值加起来是27
                
           -  所以一定有最后一枚硬币：ak
           
           -  除掉这枚硬币，前面的硬币总面值加起来是27-ak
           
    - [ ] 子问题：

         - 所以我们就要求：最少可以用多少枚硬币可以拼出27-ak
- 原问题是最少用多少枚硬币拼出27
         - 我们将原问题转化成了一个子问题，而且规模更小：27-ak
- 为了简化定义，我们设状态f(x) = 最少用多少枚硬币可以拼出x
         
如果ak是2, f(27)应该是f(27-2) + 1（加上最后这一枚硬币2）
         
         如果ak是5, f(27)应该是f(27-5) + 1（加上最后这一枚硬币5）
         
         如果ak是7, f(27)应该是f(27-7) + 1（加上最后这一枚硬币7）
         
         需要求最少的硬币数，所以：f(27) = min{f(27-2)+1, f(27-5)+1, f(27-7)+1}



​			  递归解法： 

​					int f(int x){

​						if(x == 0)return 0;

​						int res = MAX_VALUE;

​						if(x >= 2) res = Math.min(f(x-2)+1 res);

​						if(x >= 5) res = Math.min(f(x-5)+1, res);

​						if(x >= 7) res = Math.min(f(x-7)+1, res);

​					}

​			递归解法的问题：                               f(27)

​								f(25)                                  f(22)                                      f(20)

​				f(23)    f(20)    f(18)             f(20)    f(17)    f(15)                f(18)    f(15)    f(13)

​			可以看到f(20)多次用到，不仅仅用到的f(20)， 包含他底下的所有的数值。

​			做了很多重复计算，效率低下

​			而对于动态规划：东塔规划是将计算结果保存下来，并改变计算顺序

 2. 动态规划组成部分二：转移方程

    设状态f[x]=最少用多少枚硬币拼出x

    对于任意x, f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}   

	3. 动态规划组成部分三：初始条件和边界情况

    f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}   

    两个问题：x-2, x-5 或者x-7小于0怎么办？什么时候停下来？

    如果不能拼出y, 就定义f[y]=正无穷

    ​	例如f[-1] = f[-2] = .... = 正无穷

    所以f[1]=min{f[-1]+1, f[-4]+1, f[-6]+1} = 正无穷，表示拼不出来1

    初始条件：f[0] = 0. 初始条件就是用转移方程算不出来的，需要手动定义

	4. 动态规划组成部分四：计算顺序

    拼出x所需要的最少硬币数：f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}   

    初始条件：f[0] = 0

    然后计算f[1], f[2], ... , f[27]

    怎么区分从小到大还是从大到小：当我们计算到f[x]时， f[x-2], f[x-5], f[x-7]都已经得到结果了

    ​	这样就是从大到小，反之从小到大

    f[x] = 最少用多少枚硬币拼出x

    f[x] = ∞ 表示无法用硬币拼出x

    

    | ...  | f[-1] | f[0] | f[1] | f[2] | f[3] | f[4] | f[5] | f[6] | ...  | f[27] |
    | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- |
    | ∞    | ∞     | 0    | ∞    | 1    | ∞    | 2    | 1    | 3    | ...  | 5     |

    

    * 每一步尝试三种硬币，一共27步
    * 与递归算法相比，没有任何重复计算
    * 算法时间复杂度（即需要进行的步数）: 27 * 3
    * 递归的时间复杂度是指数级别， >> 27*3

	5. 小结

    * 求最值型动态规划
    * 动态规划组成部分：
      * 确定状态
        * 最后一步（最优策略中使用的最后一枚硬币ak）
        * 化成子问题（最少的硬币拼出更小的面值27-ak）
      * 转化方程
        * f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}  
      * 初始条件和边界情况
        * f[0] = 0， 如果不能拼出y, f[y] = 正无穷
      * 计算顺序
        * f[0], f[1], f[2], ...大部分从小到大
        * 使用条件是f[x-2], f[x-5], f[x-7]先于f[x]
    * 消除冗余，加速计算



code:

public int coinChange(int[] A, int M){

//如果用到0...n:数组范围开到[n+1]

//如果用到0...n-1:数组范围开到[n]

​	int[] f = new int[M+1];

​	int n = A.length; //number of kinds of coins

//initialization

​	f[0] = 0;

​	int i, j;

// f[1], f[2], ..., f[27]

​	for(i = 1; i <=M; i++){

​		f[i] = Integer.MAX_VALUE;

​		//last coin A[j]

​		// f[i] = min{f[i-A[0]]+1,..., f[i-A[n-1]]+1}

​		for(j = 0; j < n; j++){

​			if(i >= A[j] && f[i-A[j]] != Integer.MAX_VALUE){

​				f[i] = Math.min(f[i-A[j]] + 1, f[i])

​			}

​		}

​		if(f[M] == Integer.MAX_VALUE){

​			f[M] = -1;

​		}

​		return f[M];

​	}

}

